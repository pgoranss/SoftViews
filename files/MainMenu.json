{"nodes" : [{"id" : 0, "x" : 227, "y" : 303, "width" : 171, "height" : 118, "name" : "AnimatedGameObject.js", "txt" : "/**&nl;    Displays an animated Game Object&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function AnimatedGameObject()&nl;&obraces;&nl;    /**&nl;        Defines the current frame that is to be rendered&nl;        @type Number&nl;     */&nl;    this.currentFrame = 0;&nl;    /**&nl;        Defines the frames per second of the animation&nl;        @type Number&nl;     */&nl;    this.timeBetweenFrames = 0;&nl;    /**&nl;        The number of individual frames held in the image&nl;        @type Number&nl;     */&nl;    /**&nl;        Time until the next frame&nl;        @type number&nl;     */&nl;    this.timeSinceLastFrame = 0;&nl;    /**&nl;        The width of each individual frame&nl;        @type Number&nl;     */&nl;    this.frameWidth = 0;&nl;&nl;    /**&nl;        Initialises this object&nl;        @param image The image to be displayed&nl;&tb;&tb;@param x The position on the X axis&nl;        @param y The position on the Y axis&nl;&tb;&tb;@param z The depth&nl;        @param frameCount The number of animation frames in the image&nl;        @param fps The frames per second to animate this object at&nl;    */&nl;    this.startupAnimatedGameObject = function(/**Image*/ image&cm; /**Number*/ x&cm; /**Number*/ y&cm; /**Number*/ z&cm; /**Number*/ frameCount&cm; /**Number*/ fps)&nl;    &obraces;&nl;        if (frameCount &lt;= 0) throw &quote;framecount can not be &lt;= 0&quote;;&nl;        if (fps &lt;= 0) throw &quote;fps can not be &lt;= 0&quote;&nl;&nl;        this.startupVisualGameObject(image&cm; x&cm; y&cm; z);&nl;        this.currentFrame = 0;&nl;        this.frameCount = frameCount;&nl;        this.timeBetweenFrames = 1/fps;&nl;        this.timeSinceLastFrame = this.timeBetweenFrames;&nl;        this.frameWidth = this.image.width / this.frameCount;&nl;&nl;        return this;&nl;    &cbraces;&nl;&nl;    this.setAnimation = function(/**Image*/ image&cm; /**Number*/ frameCount&cm; /**Number*/ fps)&nl;    &obraces;&nl;        if (frameCount &lt;= 0) throw &quote;framecount can not be &lt;= 0&quote;;&nl;        if (fps &lt;= 0) throw &quote;fps can not be &lt;= 0&quote;&nl;&nl;        this.image = image;&nl;        this.currentFrame = 0;&nl;        this.frameCount = frameCount;&nl;        this.timeBetweenFrames = 1/fps;&nl;        this.timeSinceLastFrame = this.timeBetweenFrames;&nl;        this.frameWidth = this.image.width / this.frameCount;&nl;    &cbraces;&nl;&nl;    /**&nl;        Draws this element to the back buffer&nl;        @param dt Time in seconds since the last frame&nl;&tb;&tb;@param context The context to draw to&nl;&tb;&tb;@param xScroll The global scrolling value of the x axis&nl;&tb;&tb;@param yScroll The global scrolling value of the y axis&nl;    */&nl;    this.draw = function(/**Number*/ dt&cm; /**CanvasRenderingContext2D*/ context&cm; /**Number*/ xScroll&cm; /**Number*/ yScroll)&nl;    &obraces;&nl;        var sourceX = this.frameWidth * this.currentFrame;&nl;        context.drawImage(this.image&cm; sourceX&cm; 0&cm; this.frameWidth&cm; this.image.height&cm; this.x - xScroll&cm; this.y - yScroll&cm; this.frameWidth&cm; this.image.height);&nl;&nl;        this.timeSinceLastFrame -= dt;&nl;        if (this.timeSinceLastFrame &lt;= 0)&nl;        &obraces;&nl;           this.timeSinceLastFrame = this.timeBetweenFrames;&nl;           ++this.currentFrame;&nl;           this.currentFrame %= this.frameCount;&nl;        &cbraces;&nl;    &cbraces;&nl;&nl;    this.shutdownAnimatedGameObject = function()&nl;    &obraces;&nl;        this.shutdownVisualGameObject();&nl;    &cbraces;&nl;&nl;    this.shutdown = function()&nl;    &obraces;&nl;        this.shutdownAnimatedGameObject();&nl;    &cbraces;&nl;&nl;    this.collisionArea = function()&nl;    &obraces;&nl;        return new Rectangle().startupRectangle(this.x&cm; this.y&cm; this.frameWidth&cm; this.image.height);&nl;    &cbraces;&nl;&cbraces;&nl;&nl;AnimatedGameObject.prototype = new VisualGameObject;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;"},{"id" : 1, "x" : 436, "y" : 19, "width" : 220, "height" : 173, "name" : "ApplicationManager.js", "txt" : "/**&nl;    The ApplicationManager is used to manage the application itself.&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function ApplicationManager()&nl;&obraces;&nl;    this.canvasWidth = 0;&nl;    this.canvasHeight = 0;&nl;&nl;    /**&nl;        Initialises this object&nl;        @param canvasWidth      The width of the canvas&nl;        @param canvasHeight     The height of the canvas&nl;        @return                 A reference to the initialised object&nl;&nl;    */&nl;    this.startupApplicationManager = function(canvasWidth&cm; canvasHeight)&nl;    &obraces;&nl;        g_ApplicationManager = this;&nl;        this.canvasWidth = canvasWidth;&nl;        this.canvasHeight = canvasHeight;&nl;&nl;        this.openMainMenu();&nl;&nl;        return this;&nl;    &cbraces;&nl;&nl;    this.startLevel = function()&nl;    &obraces;&nl;        g_GameObjectManager.shutdownAll();&nl;        this.level = new Level().startupLevel(this.canvasWidth&cm; this.canvasHeight);&nl;        this.background3 = new RepeatingGameObject().startupRepeatingGameObject(g_ResourceManager.background2&cm; 0&cm; 100&cm; 3&cm; 600&cm; 320&cm; 0.75);&nl;        this.background2 = new RepeatingGameObject().startupRepeatingGameObject(g_ResourceManager.background1&cm; 0&cm; 100&cm; 2&cm; 600&cm; 320&cm; 0.5);&nl;        this.background = new RepeatingGameObject().startupRepeatingGameObject(g_ResourceManager.background0&cm; 0&cm; 0&cm; 1&cm; 600&cm; 320&cm; 0.25);&nl;        g_player = new Player().startupPlayer(this.level);&nl;        this.updateScore();&nl;    &cbraces;&nl;&nl;    this.openMainMenu = function()&nl;    &obraces;&nl;        g_GameObjectManager.shutdownAll();&nl;        g_GameObjectManager.xScroll = 0;&nl;        g_GameObjectManager.yScroll = 0;&nl;        g_score = 0;&nl;        this.mainMenu = new MainMenu().startupMainMenu();&nl;    &cbraces;&nl;&nl;    this.updateScore = function()&nl;    &obraces;&nl;        var score = document.getElementById(&quote;Score&quote;);&nl;        score.innerHTML = String(g_score);&nl;    &cbraces;&nl;&cbraces;"},{"id" : 2, "x" : 223, "y" : 12, "width" : 178, "height" : 93, "name" : "GameObject.js", "txt" : "/**&nl;    The base class for all elements that appear in the game.&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function GameObject()&nl;&obraces;&nl;    /** Display depth order. A smaller zOrder means the element is rendered first&cm; and therefor&nl;        in the background.&nl;        @type Number&nl;    */&nl;    this.zOrder = 0;&nl;    /**&nl;        The position on the X axis&nl;        @type Number&nl;    */&nl;    this.x = 0;&nl;    /**&nl;        The position on the Y axis&nl;        @type Number&nl;    */&nl;    this.y = 0;&nl;    &nl;    /**&nl;        Initialises the object&cm; and adds it to the list of objects held by the GameObjectManager.&nl;        @param x        The position on the X axis&nl;        @param y        The position on the Y axis&nl;        @param z        The z order of the element (elements in the background have a lower z value)&nl;    */&nl;    this.startupGameObject = function(/**Number*/ x&cm; /**Number*/ y&cm; /**Number*/ z)&nl;    &obraces;&nl;        this.zOrder = z;&nl;        this.x = x;&nl;        this.y = y;&nl;        g_GameObjectManager.addGameObject(this);&nl;        return this;&nl;    &cbraces;&nl;    &nl;    /**&nl;        Cleans up the object&cm; and removes it from the list of objects held by the GameObjectManager.&nl;    */&nl;    this.shutdownGameObject = function()&nl;    &obraces;&nl;        g_GameObjectManager.removeGameObject(this);&nl;    &cbraces;&nl;&nl;    this.shutdown = function()&nl;    &obraces;&nl;         this.shutdownGameObject();&nl;    &cbraces;&nl;&cbraces;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;"},{"id" : 3, "x" : 686, "y" : 198, "width" : 201, "height" : 122, "name" : "GameObjectManager.js", "txt" : "/**&nl;    A manager for all the objects in the game&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function GameObjectManager()&nl;&obraces;&nl;    /** An array of game objects &nl;        @type Arary&nl;    */&nl;    this.gameObjects = new Array();&nl;    /** An array of new game objects&nl;        @type Arary&nl;    */&nl;    this.addedGameObjects = new Array();&nl;    /** An array of removed game objects&nl;        @type Arary&nl;    */&nl;    this.removedGameObjects = new Array();&nl;    /** The time that the last frame was rendered  &nl;        @type Date&nl;    */&nl;    this.lastFrame = new Date().getTime();&nl;    /** The global scrolling value of the x axis  &nl;        @type Number&nl;    */&nl;    this.xScroll = 0;&nl;    /** The global scrolling value of the y axis  &nl;        @type Number&nl;    */&nl;    this.yScroll = 0;&nl;    /** A reference to the canvas element  &nl;        @type HTMLCanvasElement&nl;    */&nl;    this.canvas = null;&nl;    /** A reference to the 2D context of the canvas element&nl;        @type CanvasRenderingContext2D&nl;    */&nl;    this.context2D = null;&nl;    /** A reference to the in-memory canvas used as a back buffer &nl;        @type HTMLCanvasElement&nl;    */&nl;    this.backBuffer = null;&nl;    /** A reference to the backbuffer 2D context &nl;        @type CanvasRenderingContext2D&nl;    */&nl;    this.backBufferContext2D = null;&nl;    /** True if the canvas element is supported&cm; false otherwise&nl;        @type Boolean&nl;    */&nl;    this.canvasSupported = false;&nl;&tb;/** True if the resources supplied to the ResourceManager are all loaded&cm; false otherwise&nl;        @type Boolean&nl;    */&nl;    this.resourcesLoaded = false;&nl;&tb;/** The current colour of the loading screen&nl;        @type Number&nl;    */&nl;&tb;this.loadingScreenCol = 0;&nl;&tb;/** The direction of the changes to the loading screen colour.&nl;&tb;&tb;1 = colour moving towards white&nl;&tb;&tb;-1 = colour moving topwards balck&nl;        @type Number&nl;    */&tb;&nl;&tb;this.loadingScreenColDirection = 1;&nl;&tb;/** How quickly to change the loading screen colour per second&nl;        @type Number&nl;    */&nl;&tb;this.loadingScreenColSpeed = 255;&nl;&nl;    /**&nl;        Initialises this object&nl;        @return A reference to the initialised object&nl;    */&nl;    this.startupGameObjectManager = function()&nl;    &obraces;&nl;        // set the global pointer to reference this object&nl;        g_GameObjectManager = this;&nl;&nl;        // watch for keyboard events&nl;        document.onkeydown = function(event)&obraces;g_GameObjectManager.keyDown(event);&cbraces;&nl;        document.onkeyup = function(event)&obraces;g_GameObjectManager.keyUp(event);&cbraces;&nl;&nl;        // get references to the canvas elements and their 2D contexts&nl;        this.canvas = document.getElementById(&squote;canvas&squote;);&nl;&nl;        // if the this.canvas.getContext function does not exist it is a safe bet that&nl;        // the current browser does not support the canvas element.&nl;        // in this case we don&squote;t go any further&cm; which will save some debuggers (like&nl;        // the IE8 debugger) from throwing up a lot of errors.&nl;        if (this.canvas.getContext)&nl;        &obraces;&nl;            this.canvasSupported = true;&nl;            this.context2D = this.canvas.getContext(&squote;2d&squote;);&nl;            this.backBuffer = document.createElement(&squote;canvas&squote;);&nl;            this.backBuffer.width = this.canvas.width;&nl;            this.backBuffer.height = this.canvas.height;&nl;            this.backBufferContext2D = this.backBuffer.getContext(&squote;2d&squote;);&nl;        &cbraces;&nl;&nl;        // create a new ResourceManager&nl;        new ResourceManager().startupResourceManager(&nl;            [&obraces;name&cl; &squote;runLeft&squote;&cm; src&cl; &squote;run_left.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;runRight&squote;&cm; src&cl; &squote;run_right.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;idleLeft&squote;&cm; src&cl; &squote;idle_left.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;idleRight&squote;&cm; src&cl; &squote;idle_right.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;background0&squote;&cm; src&cl; &squote;jsplatformer4_b0.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;background1&squote;&cm; src&cl; &squote;jsplatformer4_b1.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;background2&squote;&cm; src&cl; &squote;jsplatformer4_b2.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;block&squote;&cm; src&cl; &squote;BlockA0.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;gem&squote;&cm; src&cl; &squote;Gem.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;mainmenu&squote;&cm; src&cl; &squote;mainmenu.png&squote;&cbraces;&cm;&nl;            &obraces;name&cl; &squote;portal&squote;&cm; src&cl; &squote;portal.png&squote;&cbraces;]);&nl;&nl;        // use setInterval to call the draw function&nl;        setInterval(function()&obraces;g_GameObjectManager.draw();&cbraces;&cm; SECONDS_BETWEEN_FRAMES);&nl;        &nl;        return this;        &nl;    &cbraces;&nl;    &nl;    /**&nl;        The render loop&nl;    */&nl;    this.draw = function ()&nl;    &obraces;&nl;        // calculate the time since the last frame&nl;        var thisFrame = new Date().getTime();&nl;        var dt = (thisFrame - this.lastFrame)/1000;&nl;        this.lastFrame = thisFrame;&nl;&nl;        if (!this.resourcesLoaded)&nl;        &obraces;&nl;            var numLoaded = 0;&nl;            for (i = 0; i &lt; g_ResourceManager.imageProperties.length; ++i)&nl;            &obraces;&nl;                if (g_ResourceManager[g_ResourceManager.imageProperties[i]].complete)&nl;                &obraces;&nl;                    ++numLoaded;&nl;                &cbraces;&nl;            &cbraces;&nl;            if ( numLoaded == g_ResourceManager.imageProperties.length )&nl;            &obraces;&nl;                // create a new ApplicationManager&nl;                new ApplicationManager().startupApplicationManager(this.canvas.width&cm; this.canvas.height);&nl;                this.resourcesLoaded = true;&nl;            &cbraces;&nl;            else&nl;            &obraces;&nl;                this.loadingScreenCol += this.loadingScreenColDirection * this.loadingScreenColSpeed * dt;&nl;                if (this.loadingScreenCol &gt; 255)&nl;                &obraces;&nl;                    this.loadingScreenCol = 255;&nl;                    this.loadingScreenColDirection = -1;&nl;                &cbraces;&nl;                else if (this.loadingScreenCol &lt; 0)&nl;                &obraces;&nl;                    this.loadingScreenCol = 0;&nl;                    this.loadingScreenColDirection = 1;&nl;                &cbraces;&nl;                this.context2D.fillStyle = &quote;rgb(&quote; + parseInt(this.loadingScreenCol) + &quote;&cm;&quote; + parseInt(this.loadingScreenCol) + &quote;&cm;&quote; + parseInt(this.loadingScreenCol) + &quote;)&quote;;&nl;                this.context2D.fillRect (0&cm; 0&cm; this.canvas.width&cm; this.canvas.height);&nl;            &cbraces;&nl;        &cbraces;&nl;        &nl;        // clear the drawing contexts&nl;        if (this.canvasSupported &amp;&amp; this.resourcesLoaded)&nl;        &obraces;&nl;            this.backBufferContext2D.clearRect(0&cm; 0&cm; this.backBuffer.width&cm; this.backBuffer.height);&nl;&nl;            this.addNewGameObjects();&nl;            this.removeOldGameObjects();&nl;        &nl;            // first update all the game objects&nl;            for (var x = 0; x &lt; this.gameObjects.length; ++x)&nl;            &obraces;&nl;                if (this.gameObjects[x].update)&nl;                &obraces;&nl;                    this.gameObjects[x].update(dt&cm; this.backBufferContext2D&cm; this.xScroll&cm; this.yScroll);&nl;                &cbraces;&nl;            &cbraces;&nl;&nl;            // then draw the game objects&nl;            for (var x = 0; x &lt; this.gameObjects.length; ++x)&nl;            &obraces;&nl;                if (this.gameObjects[x].draw)&nl;                &obraces;&nl;                    this.gameObjects[x].draw(dt&cm; this.backBufferContext2D&cm; this.xScroll&cm; this.yScroll);&nl;                &cbraces;&nl;            &cbraces;&nl;&nl;            // copy the back buffer to the displayed canvas&nl;            this.context2D.drawImage(this.backBuffer&cm; 0&cm; 0);&nl;        &cbraces;        &nl;    &cbraces;;&nl;&nl;    this.shutdownAll = function()&nl;    &obraces;&nl;        for (var x = 0; x &lt; this.gameObjects.length; ++x)&nl;        &obraces;&nl;            if (this.gameObjects[x].shutdown)&nl;            &obraces;&nl;                this.gameObjects[x].shutdown();&nl;            &cbraces;&nl;        &cbraces;&nl;&nl;        this.removeOldGameObjects();&nl;    &cbraces;&nl;    &nl;    /**&nl;        Adds a new GameObject to the gameObjects collection&nl;        @param gameObject The object to add&nl;    */&nl;    this.addGameObject = function(gameObject)&nl;    &obraces;&nl;        this.addedGameObjects.push(gameObject);&nl;    &cbraces;;&nl;&nl;    this.addNewGameObjects = function()&nl;    &obraces;&nl;        if (this.addedGameObjects.length != 0)&nl;        &obraces;&nl;            for (var x = 0; x &lt; this.addedGameObjects.length; ++x)&nl;            &obraces;&nl;                this.gameObjects.push(this.addedGameObjects[x]);&nl;            &cbraces;&nl;&nl;            this.addedGameObjects.clear();&nl;            this.gameObjects.sort(function(a&cm;b)&obraces;return a.zOrder - b.zOrder;&cbraces;);&nl;        &cbraces;&nl;    &cbraces;&nl;&nl;    /**&nl;        Removes a GameObject from the gameObjects collection&nl;        @param gameObject The object to remove&nl;    */&nl;    this.removeGameObject = function(gameObject)&nl;    &obraces;&nl;        this.removedGameObjects.push(gameObject);&nl;    &cbraces;&nl;&nl;    this.removeOldGameObjects = function()&nl;    &obraces;&nl;        if (this.removedGameObjects.length != 0)&nl;        &obraces;&nl;            for (var x = 0; x &lt; this.removedGameObjects.length; ++x)&nl;            &obraces;&nl;                this.gameObjects.removeObject(this.removedGameObjects[x]);&nl;            &cbraces;&nl;            this.removedGameObjects.clear();&nl;        &cbraces;&nl;    &cbraces;&nl;&nl;    this.keyDown = function(event)&nl;    &obraces;&nl;        for (var x = 0; x &lt; this.gameObjects.length; ++x)&nl;        &obraces;&nl;            if (this.gameObjects[x].keyDown)&nl;            &obraces;&nl;                this.gameObjects[x].keyDown(event);&nl;            &cbraces;&nl;        &cbraces;&nl;    &cbraces;&nl;&nl;    this.keyUp = function(event)&nl;    &obraces;&nl;        for (var x = 0; x &lt; this.gameObjects.length; ++x)&nl;        &obraces;&nl;            if (this.gameObjects[x].keyUp)&nl;            &obraces;&nl;                this.gameObjects[x].keyUp(event);&nl;            &cbraces;&nl;        &cbraces;&nl;    &cbraces;&nl;&cbraces;"},{"id" : 4, "x" : 733, "y" : 475, "width" : 185, "height" : 108, "name" : "Level.js", "txt" : "/**&nl;    A class to represent the level&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function Level()&nl;&obraces;&nl;    this.blocks = new Array();&nl;    this.powerups = new Object;&nl;    this.blockWidth = 64;&nl;    this.blockHeight = 48;&nl;&nl;    /**&nl;        Initialises this object&nl;    */&nl;    this.startupLevel = function(canvasWidth&cm; canvasHeight)&nl;    &obraces;&nl;        this.blocks[0] = 3;&nl;        this.blocks[1] = 2;&nl;        this.blocks[2] = 1;&nl;        this.blocks[3] = 1;&nl;        this.blocks[4] = 1;&nl;        this.blocks[5] = 1;&nl;        this.blocks[6] = 2;&nl;        this.blocks[7] = 3;&nl;        this.blocks[8] = 2;&nl;        this.blocks[9] = 1;&nl;        this.blocks[10] = 2;&nl;        this.blocks[11] = 3;&nl;        this.blocks[12] = 4;&nl;        this.blocks[13] = 5;&nl;        this.blocks[14] = 4;&nl;        this.blocks[15] = 3;&nl;&nl;        this.powerups[&squote;1&squote;] = &squote;Gem&squote;;&nl;        this.powerups[&squote;6&squote;] = &squote;Gem&squote;;&nl;        this.powerups[&squote;10&squote;] = &squote;Gem&squote;;&nl;        this.powerups[&squote;14&squote;] = &squote;LevelEndPost&squote;;&nl;&nl;        this.addBlocks(canvasWidth&cm; canvasHeight);&nl;        this.addPowerups(canvasWidth&cm; canvasHeight);&nl;&nl;        return this;&nl;    &cbraces;&nl;&nl;    /**&nl;        Adds the blocks to the screen by creating VisualGameObjects&nl;    */&nl;    this.addBlocks = function(canvasWidth&cm; canvasHeight)&nl;    &obraces;&nl;        for (var x = 0; x &lt; this.blocks.length; ++x)&nl;        &obraces;&nl;            for (var y = 0; y &lt; this.blocks[x]; ++y)&nl;            &obraces;&nl;                new VisualGameObject().startupVisualGameObject(g_ResourceManager.block&cm; x * this.blockWidth&cm; canvasHeight - (y + 1) * this.blockHeight&cm; 4);&nl;            &cbraces;&nl;        &cbraces;&nl;    &cbraces;&nl;&nl;    this.addPowerups = function(canvasWidth&cm; canvasHeight)&nl;    &obraces;&nl;        for (var x = 0; x &lt; this.blocks.length; ++x)&nl;        &obraces;&nl;            if (this.powerups[x])&nl;            &obraces;&nl;                var xPosition = x * this.blockWidth + this.blockWidth / 2;&nl;                var yPosition = canvasHeight - this.groundHeight(x);&nl;&nl;                switch(this.powerups[x])&nl;                 &obraces;&nl;                    case &squote;Gem&squote;&cl;&nl;                        new Powerup().startupPowerup(10&cm; g_ResourceManager.gem&cm; xPosition - g_ResourceManager.gem.width / 2&cm; yPosition - g_ResourceManager.gem.height&cm; 4&cm; 1&cm; 1);&nl;                        break;&nl;                    case &squote;LevelEndPost&squote;&cl;&nl;                        new LevelEndPost().startupLevelEndPost(g_ResourceManager.portal&cm; xPosition - g_ResourceManager.portal.width / 2 / 4&cm; yPosition - g_ResourceManager.portal.height&cm; 4);&nl;                        break;&nl;                 &cbraces;&nl;            &cbraces;&nl;        &cbraces;&nl;    &cbraces;&nl;&nl;    /**&nl;        @return     The block under the specified x position&nl;        @param x    The x position to test&nl;    */&nl;    this.currentBlock = function(x)&nl;    &obraces;&nl;        return parseInt( x / this.blockWidth);&nl;    &cbraces;&nl;    &nl;    /**&nl;        @return             The hieght of the ground under the specified block&nl;        @param blockIndex   The block number&nl;    */&nl;    this.groundHeight = function(blockIndex)&nl;    &obraces;&nl;        if (blockIndex &lt; 0 || blockIndex &gt; this.blocks.length) return 0;&nl;&nl;        return this.blocks[blockIndex] *  this.blockHeight;&nl;    &cbraces;&nl;&cbraces;"},{"id" : 5, "x" : 22, "y" : 486, "width" : 204, "height" : 139, "name" : "LevelEndPost.js", "txt" : "/**&nl;    An object that causes the level to end when it it touched&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function LevelEndPost()&nl;&obraces;&nl;&nl;    this.startupLevelEndPost = function(/**Image*/ image&cm; /**Number*/ x&cm; /**Number*/ y&cm; /**Number*/ z)&nl;    &obraces;&nl;        this.startupAnimatedGameObject(image&cm; x&cm; y&cm; z&cm; 4&cm; 10);&nl;        return this;&nl;    &cbraces;&nl;&nl;    this.shutdown = function()&nl;    &obraces;&nl;        this.shutdownLevelEndPost();&nl;    &cbraces;&nl;&nl;    this.shutdownLevelEndPost = function()&nl;    &obraces;&nl;        this.shutdownAnimatedGameObject();&nl;    &cbraces;&nl;&nl;    /**&nl;        Updates the object&nl;        @param dt The time since the last frame in seconds&nl;        @param context The drawing context&nl;        @param xScroll The global scrolling value of the x axis&nl;        @param yScroll The global scrolling value of the y axis&nl;    */&nl;&tb;this.update = function (/**Number*/ dt&cm; /**CanvasRenderingContext2D*/context&cm; /**Number*/ xScroll&cm; /**Number*/ yScroll)&nl;    &obraces;&nl;        if (this.collisionArea().intersects(g_player.collisionArea()))&nl;        &obraces;&nl;            g_ApplicationManager.openMainMenu();&nl;            this.shutdown();            &nl;        &cbraces;&nl;    &cbraces;&nl;&cbraces;&nl;LevelEndPost.prototype = new AnimatedGameObject;"},{"id" : 6, "x" : 14, "y" : 11, "width" : 188, "height" : 215, "name" : "Main.js", "txt" : "/** target frames per second  &nl;    @type Number&nl;*/&nl;var FPS = 30;&nl;/** time between frames &nl;    @type Number&nl;*/&nl;var SECONDS_BETWEEN_FRAMES = 1 / FPS;&nl;/** A global reference to the GameObjectManager instance  &nl;    @type GameObjectManager&nl;*/&nl;var g_GameObjectManager = null;&nl;/** A global reference to the ApplicationManager instance  &nl;    @type ApplicationManager&nl;*/&nl;var g_ApplicationManager = null;&nl;/** A global reference to the ResourceManager instance&nl;    @type ResourceManager&nl;*/&nl;var g_ResourceManager = null;&nl;/** The players score&nl;    @type Number&nl; */&nl;var g_score = 0;&nl;/** A reference to the player&nl;    @type Player    &nl; */&nl;var g_player = null;&nl;/** An image to be used by the application&nl;    @type Image&nl;*/&nl;&nl;// The entry point of the application is set to the init function&nl;window.onload = init;&nl;&nl;/**&nl;    Application entry point&nl;*/&nl;function init()&nl;&obraces;&nl;    new GameObjectManager().startupGameObjectManager();&nl;&cbraces;"},{"id" : 8, "x" : 26, "y" : 307, "width" : 153, "height" : 100, "name" : "MainMenu.js", "txt" : "/**&nl;    The main menu screen&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function MainMenu()&nl;&obraces;&nl;    this.startupMainMenu = function()&nl;    &obraces;&nl;        this.startupVisualGameObject(g_ResourceManager.mainmenu&cm; 0&cm; 0&cm; 1);&nl;        return this;&nl;    &cbraces;&nl;&nl;    /**&nl;        Called when a key is pressed&nl;        @param event Event Object&nl;    */&nl;    this.keyDown = function(event)&nl;    &obraces;&nl;        g_ApplicationManager.startLevel();&nl;    &cbraces;&nl;&cbraces;&nl;MainMenu.prototype = new VisualGameObject;"},{"id" : 9, "x" : 254, "y" : 486, "width" : 205, "height" : 148, "name" : "Player.js", "txt" : "/**&nl;    A class to represent the player on the screen&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function Player()&nl;&obraces;&nl;    /** The maximum height of the jump&nl;        @type Number&nl;     */&nl;    this.jumpHeight = 64;&nl;    /** The constant or half PI&nl;        @type Number&nl;     */&nl;    this.halfPI = Math.PI / 2;&nl;    /** The amount of time to spend in the air when jumping&nl;        @type Number&nl;     */&nl;    this.jumpHangTime = 0.5;&nl;    /** The speed to progress alone the sine wave that defines&nl;        the jumping arc&nl;        @type Number&nl;     */&nl;    this.jumpSinWaveSpeed = this.halfPI / this.jumpHangTime;&nl;    /** The current position on the sine wave that defines the jump arc&nl;        @type Number&nl;     */&nl;    this.jumpSinWavePos = 0;&nl;    /** The rate to fall at&nl;        @type Number&nl;     */&nl;    this.fallMultiplyer = 1.5;&nl;    /** True when the player is on the ground&cm; false otherwise&nl;        @type Boolean&nl;     */&nl;    this.grounded = true;&nl;    /** the players running speed&nl;        @type Number&nl;     */&nl;    this.speed = 75;&nl;    /** True if the player is moving left&cm; false otherwise&nl;        @type Boolean&nl;     */&nl;    this.left = false;&nl;    /** True if the player is moving right&cm; false otherwise&nl;        @type Boolean&nl;     */&nl;    this.right = false;&nl;    /** A reference to the level object&nl;        @type Level&nl;    */&nl;    this.level = null;&nl;    /** The distance between the player and the edge of the screen&nl;        @type Number&nl;     */&nl;    this.screenBorder = 100;&nl;&nl;    /**&nl;        Initialises this object&nl;    */&nl;    this.startupPlayer = function(level)&nl;    &obraces;&nl;        this.startupAnimatedGameObject(g_ResourceManager.idleLeft&cm; 300&cm; 400 - 48 - 48&cm; 4&cm; 6&cm; 20);&nl;        this.level = level;&nl;        return this;&nl;    &cbraces;&nl;&nl;    /**&nl;        Called when a key is pressed&nl;        @param event Event Object&nl;    */&nl;    this.keyDown = function(event)&nl;    &obraces;&nl;        var updateRequired = false;&nl;&nl;        // left&nl;        if (event.keyCode == 37 &amp;&amp; !this.left)&nl;        &obraces;&nl;            this.left = true;&nl;            updateRequired = true;&nl;        &cbraces;&nl;        // right&nl;        if (event.keyCode == 39 &amp;&amp; !this.right)&nl;        &obraces;&nl;            this.right = true;&nl;            updateRequired = true;&nl;        &cbraces;&nl;        if (event.keyCode == 32 &amp;&amp; this.grounded)&nl;        &obraces;&nl;            this.grounded = false;&nl;            this.jumpSinWavePos = 0;&nl;        &cbraces;&nl;&nl;        if (updateRequired)&nl;            this.updateAnimation();&nl;&nl;    &cbraces;&nl;&nl;    /**&nl;        Called when a key is pressed&nl;        @param event Event Object&nl;    */&nl;    this.keyUp = function(event)&nl;    &obraces;&nl;        // left&nl;        if (event.keyCode == 37)&nl;        &obraces;&nl;            this.left = false;&nl;            this.setAnimation(g_ResourceManager.idleLeft&cm; 6&cm; 20);&nl;        &cbraces;&nl;        // right&nl;        if (event.keyCode == 39)&nl;        &obraces;&nl;            this.right = false;&nl;            this.setAnimation(g_ResourceManager.idleRight&cm; 6&cm; 20);&nl;        &cbraces;&nl;&nl;        this.updateAnimation();&nl;    &cbraces;&nl;&nl;    /**&nl;        Updates the current animation depending on the movement&nl;        of the player. This accounts for the fact that both&nl;        the left and right arrow keys can be pressed at the&nl;        same time.&nl;    */&nl;    this.updateAnimation = function()&nl;    &obraces;&nl;       if (this.right &amp;&amp; this.left)&nl;            this.setAnimation(g_ResourceManager.idleLeft&cm; 6&cm; 20);&nl;        else if (this.right)&nl;            this.setAnimation(g_ResourceManager.runRight&cm; 12&cm; 20);&nl;        else if (this.left)&nl;            this.setAnimation(g_ResourceManager.runLeft&cm; 12&cm; 20);&nl;    &cbraces;&nl;&nl;    /**&nl;        Updates the object&nl;        @param dt The time since the last frame in seconds&nl;        @param context The drawing context&nl;        @param xScroll The global scrolling value of the x axis&nl;        @param yScroll The global scrolling value of the y axis&nl;    */&nl;&tb;this.update = function (/**Number*/ dt&cm; /**CanvasRenderingContext2D*/context&cm; /**Number*/ xScroll&cm; /**Number*/ yScroll)&nl;    &obraces;&nl;        if (this.left)&nl;            this.x -= this.speed * dt;&nl;        if (this.right)&nl;            this.x += this.speed * dt;&nl;&nl;        // XOR operation (JavaScript does not have a native XOR operator)&nl;        // only test for a collision if the player is moving left or right (and not trying to do both at&nl;        // the same time)&nl;        if ((this.right || this.left) &amp;&amp; !(this.left &amp;&amp; this.right))&nl;        &obraces;&nl;            // this will be true until the player is no longer colliding&nl;            var collision = false;&nl;            // the player may have to be pushed back through several block stacks (especially if the&nl;            // frame rate is very slow)&nl;            do&nl;            &obraces;&nl;                // the current position of the player (test the left side if running left&nl;                // and the right side if running right)&nl;                var xPos = this.left ? this.x &cl; this.x + this.frameWidth;&nl;                // the index of stack of blocks that the player is standing on/in&nl;                var currentBlock = this.level.currentBlock(xPos);&nl;                // the height of the stack of blocks that the player is standing on/in&nl;                var groundHeight = this.level.groundHeight(currentBlock);&nl;                // the height of the player (we need the height from the ground up&cm;&nl;                // whereas the this.y value represents the position of the player&nl;                // from the &quote;sky&quote; down).&nl;                var playerHeight = context.canvas.height - (this.y + this.image.height);&nl;                // if the player is not higher than the stack of blocks&cm; it must be colliding&nl;                if (playerHeight  &lt; groundHeight)&nl;                &obraces;&nl;                    collision = true;&nl;                    // we are moving right&cm; so push the player left&nl;                    if (this.right)&nl;                        this.x = this.level.blockWidth * currentBlock - this.frameWidth - 1;&nl;                    // we are moving left&cm; push the player right&nl;                    else&nl;                        this.x = this.level.blockWidth * (currentBlock + 1);&nl;                &cbraces;&nl;                else&nl;                &obraces;&nl;                    collision = false;&nl;                &cbraces;&nl;            &cbraces;  while (collision)&nl;        &cbraces;&nl;&nl;        // keep the player bound to the level&nl;        if (this.x &gt; this.level.blocks.length * this.level.blockWidth - this.frameWidth - 1)&nl;            this.x = this.level.blocks.length * this.level.blockWidth - this.frameWidth - 1;&nl;        if (this.x &gt; context.canvas.width - this.frameWidth + xScroll -  this.screenBorder)&nl;            g_GameObjectManager.xScroll = this.x - (context.canvas.width - this.frameWidth -  this.screenBorder);&nl;        // modify the xScroll value to keep the player on the screen&nl;        if (this.x &lt; 0)&nl;            this.x = 0;&nl;        if (this.x -  this.screenBorder &lt; xScroll)&nl;            g_GameObjectManager.xScroll = this.x - this.screenBorder;&nl;&nl;        // if the player is jumping or falling&cm; move along the sine wave&nl;        if (!this.grounded)&nl;        &obraces;&nl;            // the last position on the sine wave&nl;            var lastHeight = this.jumpSinWavePos;&nl;            // the new position on the sine wave&nl;            this.jumpSinWavePos += this.jumpSinWaveSpeed * dt;&nl;&nl;            // we have fallen off the bottom of the sine wave&cm; so continue falling&nl;            // at a predetermined speed&nl;            if (this.jumpSinWavePos &gt;= Math.PI)&nl;                 this.y += this.jumpHeight / this.jumpHangTime * this.fallMultiplyer * dt;&nl;            // otherwise move along the sine wave&nl;            else&nl;                this.y -= (Math.sin(this.jumpSinWavePos) - Math.sin(lastHeight)) * this.jumpHeight;&nl;        &cbraces;&nl;&nl;        // now that the player has had it&squote;s y position changed we need to check for a collision&nl;        // with the ground below the player. we have to check both the players left and right sides&nl;        // for a collision with the ground&nl;&nl;        // left side&nl;        var currentBlock1 = this.level.currentBlock(this.x);&nl;        // right side&nl;        var currentBlock2 = this.level.currentBlock(this.x + this.frameWidth);&nl;        // ground height below the left side&nl;        var groundHeight1 = this.level.groundHeight(currentBlock1);&nl;        // ground height below the right side&nl;        var groundHeight2 = this.level.groundHeight(currentBlock2);&nl;        // the heighest point under the player&nl;        var maxGroundHeight = groundHeight1 &gt; groundHeight2 ? groundHeight1 &cl; groundHeight2;&nl;        // the players height (relaitive to the bottom of the screen)&nl;        var playerHeight = context.canvas.height - (this.y + this.image.height);&nl;&nl;        // we have hit the ground&nl;        if (maxGroundHeight &gt;= playerHeight)&nl;        &obraces;&nl;            this.y = context.canvas.height - maxGroundHeight - this.image.height;&nl;            this.grounded = true;&nl;            this.jumpSinWavePos = 0;&nl;        &cbraces;&nl;        // otherwise we are falling&nl;        else if (this.grounded)&nl;        &obraces;&nl;            this.grounded = false;&nl;            // starting falling down the sine wave (i.e. from the top)&nl;            this.jumpSinWavePos = this.halfPI;&nl;        &cbraces;&nl;    &cbraces;&nl;&cbraces;&nl;&nl;Player.prototype = new AnimatedGameObject;"},{"id" : 10, "x" : 488, "y" : 483, "width" : 215, "height" : 159, "name" : "Powerup.js", "txt" : "/**&nl;    Represents a powerup in the game&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function Powerup()&nl;&obraces;&nl;    /** The value of the powerup&nl;        @type Number&nl;     */&nl;    this.value = 0;&nl;    /** The current position on the sine wave&nl;        @type Number&nl;     */&nl;    this.sineWavePos = 0;&nl;    /** How quickly the powerup cycles through the sine wave&nl;        @type Number&nl;     */&nl;    this.bounceTime = 1;&nl;    /** The speed to increment the sineWavePos value at&nl;        @type Number&nl;     */&nl;    this.bounceSpeed = Math.PI / this.bounceTime;&nl;    /** The height of the powerups bounce&nl;        @type Number&nl;     */&nl;    this.bounceHeight = 10;&nl;&nl;    /**&nl;        Initialises this object&nl;        @param value        The value (score) of this powerup&nl;        @param image        The image to be displayed&nl;        @param x            The position on the X axis&nl;        @param y            The position on the Y axis&nl;        @param z            The depth&nl;        @param frameCount   The number of animation frames in the image&nl;        @param fps          The frames per second to animate this object at&nl;     */&nl;    this.startupPowerup = function(/**Number*/ value&cm; /**Image*/ image&cm; /**Number*/ x&cm; /**Number*/ y&cm; /**Number*/ z&cm; /**Number*/ frameCount&cm; /**Number*/ fps)&nl;    &obraces;&nl;        this.startupAnimatedGameObject(image&cm; x&cm; y - this.bounceHeight&cm; z&cm; frameCount&cm; fps);&nl;        this.value = value;&nl;        return this;&nl;    &cbraces;&nl;&nl;    this.shutdownPowerup = function()&nl;    &obraces;&nl;        this.shutdownAnimatedGameObject();&nl;    &cbraces;&nl;&nl;    this.shutdown = function()&nl;    &obraces;&nl;        this.shutdownPowerup();&nl;    &cbraces;&nl;&nl;    /**&nl;        Updates the object&nl;        @param dt The time since the last frame in seconds&nl;        @param context The drawing context&nl;        @param xScroll The global scrolling value of the x axis&nl;        @param yScroll The global scrolling value of the y axis&nl;    */&nl;&tb;this.update = function (/**Number*/ dt&cm; /**CanvasRenderingContext2D*/context&cm; /**Number*/ xScroll&cm; /**Number*/ yScroll)&nl;    &obraces;&nl;        var lastSineWavePos = this.sineWavePos;&nl;        this.sineWavePos += this.bounceSpeed * dt;&nl;        this.y += (Math.sin(this.sineWavePos) - Math.sin(lastSineWavePos)) * this.bounceHeight;&nl;&nl;        if (this.collisionArea().intersects(g_player.collisionArea()))&nl;        &obraces;&nl;            this.shutdown();&nl;            g_score += this.value;&nl;            g_ApplicationManager.updateScore();&nl;        &cbraces;&nl;    &cbraces;&nl;&cbraces;&nl;&nl;Powerup.prototype = new AnimatedGameObject;"},{"id" : 11, "x" : 709, "y" : 351, "width" : 156, "height" : 99, "name" : "Rectangle.js", "txt" : "/**&nl;    A rectangle&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function Rectangle()&nl;&obraces;&nl;    this.left = 0;&nl;    this.top = 0;&nl;    this.width = 0;&nl;    this.height = 0;&nl;&nl;    /**&nl;        Initialises the object&nl;        @param left     Left position&nl;        @param top      Top Position&nl;        @param width    Width of rectangle&nl;        @param height   Height of triangle&nl;     */&nl;    this.startupRectangle = function(/**Number*/ left&cm; /**Number*/ top&cm; /**Number*/ width&cm; /**Number*/ height)&nl;    &obraces;&nl;        this.left = left;&nl;        this.top = top;&nl;        this.width = width;&nl;        this.height = height;&nl;        return this;&nl;    &cbraces;&nl;&nl;    /**&nl;        @return         true if there is an intersection&cm; false otherwise&nl;        @param other    The other rectangle to test against&nl;     */&nl;    this.intersects = function(/**Rectangle*/ other)&nl;    &obraces;&nl;        if (this.left + this.width &lt; other.left)&nl;            return false;&nl;        if (this.top + this.height &lt; other.top)&nl;            return false;&nl;        if (this.left &gt; other.left + other.width)&nl;            return false;&nl;        if (this.top &gt; other.top + other.height)&nl;            return false;&nl;&nl;        return true;&nl;    &cbraces;&nl;&cbraces;"},{"id" : 12, "x" : 435, "y" : 309, "width" : 175, "height" : 106, "name" : "RepeatingGameObject.js", "txt" : "/**&nl;    A class that display a repeating texture that can optionall be offset in either&nl;&tb;the x or y axis&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function RepeatingGameObject()&nl;&obraces;&nl;    /** The width that the final image will take up&nl;&tb;&tb;@type Number&nl;&tb;*/&nl;&tb;this.width = 0;&nl;&tb;/** The height that the final image will take up&nl;&tb;&tb;@type Number&nl;&tb;*/&nl;    this.height = 0;&nl;&tb;/** How much of the scrollX and scrollY to apply when drawing&nl;&tb;&tb;@type Number&nl;&tb;*/&nl;    this.scrollFactor = 1;&nl;&tb;&nl;    /**&nl;        Initialises this object&nl;        @return A reference to the initialised object&nl;    */&nl;    this.startupRepeatingGameObject = function(image&cm; x&cm; y&cm; z&cm; width&cm; height&cm; scrollFactor)&nl;    &obraces;&nl;        this.startupVisualGameObject(image&cm; x&cm; y&cm; z);&nl;        this.width = width;&nl;        this.height = height;&nl;        this.scrollFactor = scrollFactor;&nl;        return this;&nl;    &cbraces;&nl;&tb;&nl;    /**&nl;        Clean this object up&nl;    */&nl;    this.shutdownstartupRepeatingGameObject = function()&nl;    &obraces;&nl;        this.shutdownVisualGameObject();&nl;    &cbraces;&nl;    &nl;&tb;/**&nl;        Draws this element to the back buffer&nl;        @param dt Time in seconds since the last frame&nl;&tb;&tb;@param context The context to draw to&nl;&tb;&tb;@param xScroll The global scrolling value of the x axis  &nl;&tb;&tb;@param yScroll The global scrolling value of the y axis  &nl;    */&nl;    this.draw = function(dt&cm; canvas&cm; xScroll&cm; yScroll)&nl;    &obraces;&nl;        var areaDrawn = [0&cm; 0];&nl;        &nl;        for (var y = 0; y &lt; this.height; y += areaDrawn[1])&nl;        &obraces;&nl;            for (var x = 0; x &lt; this.width; x += areaDrawn[0])&nl;            &obraces;&nl;                // the top left corner to start drawing the next tile from&nl;&tb;&tb;&tb;&tb;var newPosition = [this.x + x&cm; this.y + y];&nl;&tb;&tb;&tb;&tb;// the amount of space left in which to draw&nl;                var newFillArea = [this.width - x&cm; this.height - y];&nl;&tb;&tb;&tb;&tb;// the first time around you have to start drawing from the middle of the image&nl;&tb;&tb;&tb;&tb;// subsequent tiles alwyas get drawn from the top or left&nl;                var newScrollPosition = [0&cm; 0];&nl;                if (x==0) newScrollPosition[0] = xScroll * this.scrollFactor;&nl;                if (y==0) newScrollPosition[1] = yScroll * this.scrollFactor;&nl;                areaDrawn = this.drawRepeat(canvas&cm; newPosition&cm; newFillArea&cm; newScrollPosition);&nl;            &cbraces;&nl;        &cbraces;&nl;    &cbraces;&nl;    &nl;    this.drawRepeat = function(canvas&cm; newPosition&cm; newFillArea&cm; newScrollPosition)&nl;    &obraces;&nl;        // find where in our repeating texture to start drawing (the top left corner)&nl;        var xOffset = Math.abs(newScrollPosition[0]) % this.image.width;&nl;        var yOffset = Math.abs(newScrollPosition[1]) % this.image.height;&nl;        var left = newScrollPosition[0]&lt;0?this.image.width-xOffset&cl;xOffset;&nl;        var top = newScrollPosition[1]&lt;0?this.image.height-yOffset&cl;yOffset;&nl;        var width = newFillArea[0] &lt; this.image.width-left?newFillArea[0]&cl;this.image.width-left;&nl;        var height = newFillArea[1] &lt; this.image.height-top?newFillArea[1]&cl;this.image.height-top;&nl;        &nl;        // draw the image&nl;        canvas.drawImage(this.image&cm; left&cm; top&cm; width&cm; height&cm; newPosition[0]&cm; newPosition[1]&cm; width&cm; height);&nl;        &nl;        return [width&cm; height];&nl;    &cbraces;&nl;    &nl;    &nl;&cbraces;&nl;RepeatingGameObject.prototype = new VisualGameObject();"},{"id" : 13, "x" : 680, "y" : 21, "width" : 210, "height" : 161, "name" : "ResourceManager.js", "txt" : "/**&nl;    A database for the external resources used by the game&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function ResourceManager()&nl;&obraces;&nl;&tb;/** An array of the names of the images supplied to the startupResourceManager&nl;&tb;&tb;function. Since the images are referenced by creating new properties&nl;&tb;&tb;of the ResourceManager class this collection allows a developer to &nl;&tb;&tb;know which of the ResourceManager properties are images&cm; and (by &nl;&tb;&tb;elimination) those that are not&nl;&tb;&tb;@type Array&nl;&tb;*/&nl;    this.imageProperties = null;&nl;&nl;&tb;/**&nl;        Initialises this object&nl;&tb;&tb;@param images&tb;An array of objects with the name and src properties&nl;        @return &tb;&tb;A reference to the initialised object&nl;    */&nl;    this.startupResourceManager = function(/**Array*/ images)&nl;    &obraces;&nl;        // set the global variable&nl;&tb;&tb;g_ResourceManager = this;&nl;&nl;        // initialize internal state.&nl;        this.imageProperties = new Array();&nl;&nl;        // for each image&cm; call preload()&nl;        for ( var i = 0; i &lt; images.length; i++ )&nl;&tb;&tb;&obraces;&nl;&tb;&tb;&tb;// create new Image object and add to array&nl;&tb;&tb;&tb;var thisImage = new Image;&nl;&tb;&tb;&tb;this[images[i].name] = thisImage;&nl;&tb;&tb;&tb;this.imageProperties.push(images[i].name);&nl;&nl;&tb;&tb;&tb;// assign the .src property of the Image object&nl;&tb;&tb;&tb;thisImage.src = images[i].src;&nl;&tb;&tb;&cbraces;&nl;&nl;        return this;&nl;    &cbraces;&nl;&cbraces;"},{"id" : 14, "x" : 743, "y" : 608, "width" : 178, "height" : 109, "name" : "Utils.js", "txt" : "/**&nl;    Removes a number of objects from the array&nl;    @param from The first object to remove&nl;    @param to (Optional) The last object to remove&nl;*/&nl;Array.prototype.remove = function(/**Number*/ from&cm; /**Number*/ to)&nl;&obraces;&nl;  var rest = this.slice((to || from) + 1 || this.length);&nl;  this.length = from &lt; 0 ? this.length + from &cl; from;&nl;  return this.push.apply(this&cm; rest);&nl;&cbraces;;&nl;&nl;/**&nl;    Removes a specific object from the array&nl;    @param object The object to remove&nl;*/&nl;Array.prototype.removeObject = function(object)&nl;&obraces;&nl;    for (var i = 0; i &lt; this.length; ++i)&nl;    &obraces;&nl;        if (this[i] === object)&nl;        &obraces;&nl;            this.remove(i);&nl;            break;&nl;        &cbraces;&nl;    &cbraces;&nl;&cbraces;"},{"id" : 15, "x" : 229, "y" : 150, "width" : 164, "height" : 94, "name" : "VisualGameObject.js", "txt" : "/**&nl;    The base class for all elements that appear in the game.&nl;    @author &lt;a href=&quote;mailto&cl;matthewcasperson@gmail.com&quote;&gt;Matthew Casperson&lt;/a&gt;&nl;    @class&nl;*/&nl;function VisualGameObject()&nl;&obraces;&nl;    /**&nl;        The image that will be displayed by this object&nl;        @type Image&nl;    */&nl;    this.image = null;&nl;    &nl;    /**&nl;        Draws this element to the back buffer&nl;        @param dt Time in seconds since the last frame&nl;&tb;&tb;@param context The context to draw to&nl;&tb;&tb;@param xScroll The global scrolling value of the x axis  &nl;&tb;&tb;@param yScroll The global scrolling value of the y axis  &nl;    */&nl;    this.draw = function(/**Number*/ dt&cm; /**CanvasRenderingContext2D*/ context&cm; /**Number*/ xScroll&cm; /**Number*/ yScroll)&nl;    &obraces;&nl;        context.drawImage(this.image&cm; this.x - xScroll&cm; this.y - yScroll);&nl;    &cbraces;&nl;    &nl;    /**&nl;        Initialises this object&nl;        @param image The image to be displayed&nl;&tb;&tb;@param x The position on the X axis&nl;        @param y The position on the Y axis&nl;&tb;&tb;@param z The depth&nl;    */&nl;    this.startupVisualGameObject = function(/**Image*/ image&cm; /**Number*/ x&cm; /**Number*/ y&cm; /**Number*/ z)&nl;    &obraces;&nl;        this.startupGameObject(x&cm; y&cm; z);&nl;        this.image = image;&nl;        return this;&nl;    &cbraces;&nl;    &nl;    /**&nl;        Clean this object up&nl;    */&nl;    this.shutdownVisualGameObject = function()&nl;    &obraces;&nl;        this.image = null;&nl;        this.shutdownGameObject();&nl;    &cbraces;&nl;&nl;    this.shutdown = function()&nl;    &obraces;&nl;        this.shutdownVisualGameObject();&nl;    &cbraces;&nl;&nl;    this.collisionArea = function()&nl;    &obraces;&nl;        return new Rectangle().startupRectangle(this.x&cm; this.y&cm; this.image.width&cm; this.image.height);&nl;    &cbraces;&nl;&cbraces;&nl;VisualGameObject.prototype = new GameObject;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;&nl;"}], "connections" : [{"nodeA" : 0, "nodeB" : 15, "conA" : "top", "conB" : "bottom"},{"nodeA" : 5, "nodeB" : 0, "conA" : "top", "conB" : "bottom"},{"nodeA" : 8, "nodeB" : 15, "conA" : "top", "conB" : "bottom"},{"nodeA" : 9, "nodeB" : 0, "conA" : "top", "conB" : "bottom"},{"nodeA" : 10, "nodeB" : 0, "conA" : "top", "conB" : "bottom"},{"nodeA" : 12, "nodeB" : 15, "conA" : "top", "conB" : "bottom"},{"nodeA" : 2, "nodeB" : 15, "conA" : "bottom", "conB" : "top"}]}